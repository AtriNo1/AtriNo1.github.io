{"posts":[{"title":"Atri的Re之旅(1)","text":"本章我会带来moectf2025-Re向的非官方WP test1:speed1，Die查壳，发现无壳2,运行exe，发现打开后迅速结束窗口3，打开ida4,追踪WinMain函数，发现sleep(1u),设下断点5,动态调试 test2:base1，die查壳：无壳的PE64文件2，虚拟机运行，发现需要填写flag3，打开ida4，Main函数： 12345678910111213141516171819202122232425262728293031323334353637383940int __fastcall main(int argc, const char **argv, const char **envp){ Stream *Stream; // rax __int64 v4; // rdx __int64 v5; // rax unsigned __int64 n0x64; // rax char *Str1; // rbx int v8; // eax char *Format; // rcx _QWORD v11[2]; // [rsp+20h] [rbp-98h] BYREF char Buffer[112]; // [rsp+30h] [rbp-88h] BYREF sub_140001010(Format); sub_140001010((char *)&amp;Format_); Stream = _acrt_iob_func(0); fgets(Buffer, 100, Stream); v4 = -1; v5 = -1; do ++v5; while ( Buffer[v5] ); if ( v5 &amp;&amp; *((_BYTE *)&amp;v11[1] + v5 + 7) == 10 ) { n0x64 = v5 - 1; if ( n0x64 &gt;= 0x64 ) sub_140001448(Buffer); Buffer[n0x64] = 0; } do ++v4; while ( Buffer[v4] ); Str1 = (char *)sub_140001070(Buffer, v4, v11); v8 = strcmp(Str1, &quot;bW9lY3Rme1kwdV9DNG5fRzAwZF9BdF9CNDVlNjQhIX0=&quot;); Format = (char *)&amp;unk_140003300; if ( v8 ) Format = (char *)&amp;byte_140003318; sub_140001010(Format); free(Str1); return 0;}","link":"/2025/10/20/Atri%E7%9A%84Re%E4%B9%8B%E6%97%85-1/"},{"title":"自我介绍","text":"这里是AtriNo.1,一位刚入门的CTFer，主攻Re，也会玩点misc。","link":"/2025/10/27/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"},{"title":"Atri的unity之旅(1)","text":"在本章，我会介绍unity组件基类MonoBehaviour(生命周期函数),组件:Transform,Component相关语法,CharacterController,Rigidbody。 MonoBehaviour 基类与生命周期生命周期函数是指那些在游戏对象的生命周期内由Unity引擎自动调用的特殊函数。这些函数按照特定的顺序执行，允许开发者在游戏对象被创建、激活、更新或销毁时执行代码。 初始化123Awake ；脚本实例被加载时调用，​无论脚本是否启用。用于初始化变量或游戏状态。OnEnable:当脚本被启用或激活时调用。​可多次执行​（如物体反复激活/禁用）。Start:在第一次 Update 调用前，且脚本启用时执行。常用于依赖其他组件完成的初始化。 物理模拟1234FixedUpdate：在固定的时间间隔​（默认0.02秒）调用，与帧率无关。​必须用于物理计算​（如力、碰撞）。OnTrigger[Enter,Stay,Exit]:当碰撞体进入/停留/离开触发器时调用。OnCollision[Enter,Stay,Exit]：当发生碰撞时调用。tips：OnCollisionEnter方法必须是在两个碰撞物体都不勾选isTrigger的前提下才能进入，反之只要勾选一个isTrigger那么就能进入OnTriggerEnter方法。 游戏逻辑12Update：每帧调用一次，是游戏核心逻辑（如输入检测、非物理移动）的主要位置。LateUpdate：在所有 Update 执行完毕后调用。常用于相机跟随，确保目标物体已移动完毕。 结束12OnDisable：当脚本被禁用或物体变为非激活时调用。用于清理当前状态。OnDestroy：当物体被销毁时调用。用于释放资源、清理内存。 transform 世界的坐标位置；123transform.position = new Vector();transform.localPosition = new Vector3();tips：记得区别世界坐标与相对坐标 旋转12345设置绝对朝向：transform.rotation = Quaternion.Euler();相对方向旋转：transform.localRotation = Quaternion.Euler();对应的欧拉角表示为：transform.eulerAngles = new Vector3();transform.localeulerAngles = new Vector3(); 放缩1transform.localScale = new Vector3(); 朝向与方向1transform.[up,forward,right]：是以物体自身为坐标轴重建的正方向。 父与子12transform.SetParent(Transform parent, bool worldPositionStays = true);Transform top = transform.root;//设置top为最高层级 坐标系转换12345Vector worldpoint=transfom.TransformPoint(localpoint)；//将相对this的局部坐标转化为世界坐标Vector3 localPoint = A.transform.InverseTransformPoint(worldPoint);//将世界坐标转化为相对于A的局部坐标Vector3 worldDirection = TransformDirection(localDirection);//将局部方向转换为世界方向Vector3 localDirection = InverseTransformDirection(worldDirection);//transformDirection的逆方向TransformVector(Vector3 localVector)/InverseTransformVector(Vector3 worldVector)//效果同上，但是会考虑缩放 移动与旋转123456transform.Translate(Vector3.forward * Time.deltaTime * speed);//// 默认为 Space.Selftransform.Translate(Vector3.right * 1f, Space.World);//世界坐标下的移动transform.Rotate();//方向*度数（默认为本地坐标）LookAt(Transform target)/LookAt(Vector3 worldPosition)//看向物体Quaternion targetRot = Quaternion.LookRotation(targetPos - transform.position);//生成四元数朝向（用于平滑旋转或插值）transform.SetPositionAndRotation(newPos, Quaternion.Euler());//同时设置位置与旋转 Component 组件获取组件12例：Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();//获取某个游戏对象的组件例：Transform childTransform = gameObject.transform.GetChild(0).GetComponent&lt;Transform&gt;();//获取子对象的组件 添加组件12Rigidbody rb = gameObject.AddComponent&lt;Rigidbody&gt;()//为物体添加组件MyScript myScript = gameObject.AddComponent&lt;MyScript&gt;();//为物体添加脚本 移除组件1Destroy(gameObject.GetComponent&lt;Collider&gt;(), time);//time表示销毁延迟（可省） 启用与禁用1Component.enabled=(bool); 通过类型获取组件123Collider[] colliders = gameObject.GetComponents&lt;Collider&gt;();//获取所有collider组件Rigidbody rbInChildren = gameObject.GetComponentInChildren&lt;Rigidbody&gt;();//获取子物体组件TryGetComponent//尝试获取组件(if) Rigidbody 刚体物理力相关12345AddForce//施加力，可以指定力的类型Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();Vector3 force = new Vector3(10f, 0f, 0f); //设置力的方向rb.AddForce(force,ForceMode.Impulse);//四种ForceMode：Force,Acceleraton,Impulse,VelocityChange 1234AddTorque//添加扭矩用于模拟旋转Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();Vector3 torque = new Vector3(0f, 10f, 0f); // 沿 Y 轴的旋转rb.AddTorque(torque); 1234AddRelativeForce//添加本地系力Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();Vector3 localForce = new Vector3(10f, 0f, 0f); // 在本地空间内的力rb.AddRelativeForce(localForce); 1234AddRelativeTorque//添加本地系扭矩Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();Vector3 localTorque = new Vector3(0f, 5f, 0f); // 在本地空间内的扭矩rb.AddRelativeTorque(localTorque); 1AddForceAtPosition(Vector3 force, Vector3 position)//在指定位置创造力 状态控制函数123Sleep()// 让物体进入休眠状态Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();rb.Sleep(); 123WakeUp()//唤醒刚体，使其重新参与物理计算Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();rb.WakeUp(); 123IsSleeping()// 返回物体是否休眠的状态Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();bool isSleeping = rb.IsSleeping(); 123DetectCollisions//是否进行碰撞检测Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();rb.detectCollisions = true; 物理属性设置函数1234567891011velocity//速度angularVelocity//角速度drag//线性阻力angularDrag//角阻力mass//质量useGravity//是否启用重力isKinematic//是否是运动学物体constraints//设置物体约束Vector:Velocity,angularVelocityfloat:drag angulaiDrag massbool:useGravity,isKinematic 位移与旋转12MovePosition(Vector3 position)MoveRotation(Quaternion rot) CharacterController 角色控制器移动与碰撞函数12345move()CharacterController cc = GetComponent&lt;CharacterController&gt;();Vector3 move = new Vector3(0, 0, 5f) * Time.deltaTime;CollisionFlags flag = cc.Move(move);//返回碰撞信息//None：无碰撞/Sides：侧面碰撞/Above：上方碰撞/Below：下方碰撞（落地） 12SimpleMove(Vector3 speed)//与Move类似，但自动添加重力效果bool SimpleMove(Vector3 speed);//true：落地,flase：在空中 检测与状态属性123isGrounded//判断角色是否在地面上velocity//返回当前速度enabled//启用或禁用 物理属性1234heightradiuscenterskinwidth 爬坡设置123stepOffset//角色可以跨越的最大台阶高度slopeLimit//可行走的最大坡度角度minMoveDistance//忽略的最小位移距离 碰撞等检测12detectCollisons//同上enableOverlapRecovery//是否在卡入障碍物后自动推出","link":"/2025/10/19/unity%E4%B9%8B%E6%97%85%E4%B8%80%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"Rewp","slug":"Rewp","link":"/tags/Rewp/"},{"name":"Re","slug":"Re","link":"/tags/Re/"},{"name":"Fresher","slug":"Fresher","link":"/tags/Fresher/"},{"name":"unity","slug":"unity","link":"/tags/unity/"},{"name":"组件","slug":"组件","link":"/tags/%E7%BB%84%E4%BB%B6/"}],"categories":[{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"unity","slug":"unity","link":"/categories/unity/"}],"pages":[]}