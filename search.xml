<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Atri的Re之旅(2)</title>
    <url>/2025/11/10/Atri%E7%9A%84Re%E4%B9%8B%E6%97%85-2/</url>
    <content><![CDATA[<!-- 这里是摘要部分，以上内容会在首页显示 -->
<p>本章我会带来Qctf-Re向的非官方WP</p>
<span id="more"></span>
<!-- 这里是文章的剩余内容 -->
<h2 id="Week-1"><a href="#Week-1" class="headerlink" title="Week 1"></a>Week 1</h2><h3 id="test1-8086ASM"><a href="#test1-8086ASM" class="headerlink" title="test1:8086ASM"></a>test1:8086ASM</h3>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Rewp</tag>
      </tags>
  </entry>
  <entry>
    <title>25年Re例会作业</title>
    <url>/2025/11/11/25%E5%B9%B4Re%E4%BE%8B%E4%BC%9A%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<!-- 这里是摘要部分，以上内容会在首页显示 -->
<p>例会作业</p>
<span id="more"></span>
<!-- 这里是文章的剩余内容 -->
<h2 id="2025-11-10"><a href="#2025-11-10" class="headerlink" title="2025.11.10"></a>2025.11.10</h2><h3 id="test1-蛇年的本命语言"><a href="#test1-蛇年的本命语言" class="headerlink" title="test1:蛇年的本命语言"></a>test1:蛇年的本命语言</h3><p>根据课上的提示，我们逆向得到原py文件<br><img src="/meeting/11.10/test1-1.png"><br>不难看出是z3约束，写出脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python</span><br><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = [Int(&#x27;x_%i&#x27; % i) for i in range(30)]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.add(7 * x[0] == 504)</span><br><span class="line">s.add(9 * x[0] - 5 * x[1] == 403)</span><br><span class="line">s.add((2 * x[0] - 5 * x[1]) + 10 * x[2] == 799)</span><br><span class="line">s.add(3 * x[0] + 8 * x[1] + 15 * x[2] + 20 * x[3] == 2938)</span><br><span class="line">s.add((5 * x[0] + 15 * x[1] + 20 * x[2] - 19 * x[3]) + 1 * x[4] == 2042)</span><br><span class="line">s.add((7 * x[0] + 1 * x[1] + 9 * x[2] - 11 * x[3]) + 2 * x[4] + 5 * x[5] == 1225)</span><br><span class="line">s.add(11 * x[0] + 22 * x[1] + 33 * x[2] + 44 * x[3] + 55 * x[4] + 66 * x[5] - 77 * x[6] == 7975)</span><br><span class="line">s.add(((21 * x[0] + 23 * x[1] + 3 * x[2] + 24 * x[3] - 55 * x[4]) + 6 * x[5] - 7 * x[6]) + 15 * x[7] == 229)</span><br><span class="line">s.add((2 * x[0] + 26 * x[1] + 13 * x[2] + 0 * x[3] - 65 * x[4]) + 15 * x[5] + 29 * x[6] + 1 * x[7] + 20 * x[8] == 2107)</span><br><span class="line">s.add((10 * x[0] + 7 * x[1] + -9 * x[2] + 6 * x[3] + 7 * x[4] + 1 * x[5] + 22 * x[6] + 21 * x[7] - 22 * x[8]) + 30 * x[9] == 4037)</span><br><span class="line">s.add((15 * x[0] + 59 * x[1] + 56 * x[2] + 66 * x[3] + 7 * x[4] + 1 * x[5] - 122 * x[6]) + 21 * x[7] + 32 * x[8] + 3 * x[9] - 10 * x[10] == 4950)</span><br><span class="line">s.add((((13 * x[0] + 66 * x[1] + 29 * x[2] + 39 * x[3] - 33 * x[4]) + 13 * x[5] - 2 * x[6]) + 42 * x[7] + 62 * x[8] + 1 * x[9] - 10 * x[10]) + 11 * x[11] == 12544)</span><br><span class="line">s.add((((23 * x[0] + 6 * x[1] + 29 * x[2] + 3 * x[3] - 3 * x[4]) + 63 * x[5] - 25 * x[6]) + 2 * x[7] + 32 * x[8] + 1 * x[9] - 10 * x[10]) + 11 * x[11] - 12 * x[12] == 6585)</span><br><span class="line">s.add(((((223 * x[0] + 6 * x[1] - 29 * x[2] - 53 * x[3] - 3 * x[4]) + 3 * x[5] - 65 * x[6]) + 0 * x[7] + 36 * x[8] + 1 * x[9] - 15 * x[10]) + 16 * x[11] - 18 * x[12]) + 13 * x[13] == 6893)</span><br><span class="line">s.add(((((29 * x[0] + 13 * x[1] - 9 * x[2] - 93 * x[3]) + 33 * x[4] + 6 * x[5] + 65 * x[6] + 1 * x[7] - 36 * x[8]) + 0 * x[9] - 16 * x[10]) + 96 * x[11] - 68 * x[12]) + 33 * x[13] - 14 * x[14] == 1883)</span><br><span class="line">s.add((((69 * x[0] + 77 * x[1] - 93 * x[2] - 12 * x[3]) + 0 * x[4] + 0 * x[5] + 1 * x[6] + 16 * x[7] + 36 * x[8] + 6 * x[9] + 19 * x[10] + 66 * x[11] - 8 * x[12]) + 38 * x[13] - 16 * x[14]) + 15 * x[15] == 8257)</span><br><span class="line">s.add(((((23 * x[0] + 2 * x[1] - 3 * x[2] - 11 * x[3]) + 12 * x[4] + 24 * x[5] + 1 * x[6] + 6 * x[7] + 14 * x[8] - 0 * x[9]) + 1 * x[10] + 68 * x[11] - 18 * x[12]) + 68 * x[13] - 26 * x[14]) + 15 * x[15] - 16 * x[16] == 5847)</span><br><span class="line">s.add((((((24 * x[0] + 0 * x[1] - 1 * x[2] - 15 * x[3]) + 13 * x[4] + 4 * x[5] + 16 * x[6] + 67 * x[7] + 146 * x[8] - 50 * x[9]) + 16 * x[10] + 6 * x[11] - 1 * x[12]) + 69 * x[13] - 27 * x[14]) + 45 * x[15] - 6 * x[16]) + 17 * x[17] == 18257)</span><br><span class="line">s.add(((((25 * x[0] + 26 * x[1] - 89 * x[2]) + 16 * x[3] + 19 * x[4] + 44 * x[5] + 36 * x[6] + 66 * x[7] - 150 * x[8] - 250 * x[9]) + 166 * x[10] + 126 * x[11] - 11 * x[12]) + 690 * x[13] - 207 * x[14]) + 46 * x[15] + 6 * x[16] + 7 * x[17] - 18 * x[18] == 12591)</span><br><span class="line">s.add((((((5 * x[0] + 26 * x[1] + 8 * x[2] + 160 * x[3] + 9 * x[4] - 4 * x[5]) + 36 * x[6] + 6 * x[7] - 15 * x[8] - 20 * x[9]) + 66 * x[10] + 16 * x[11] - 1 * x[12]) + 690 * x[13] - 20 * x[14]) + 46 * x[15] + 6 * x[16] + 7 * x[17] - 18 * x[18]) + 19 * x[19] == 52041)</span><br><span class="line">s.add(((((((29 * x[0] - 26 * x[1]) + 0 * x[2] + 60 * x[3] + 90 * x[4] - 4 * x[5]) + 6 * x[6] + 6 * x[7] - 16 * x[8] - 21 * x[9]) + 69 * x[10] + 6 * x[11] - 12 * x[12]) + 69 * x[13] - 20 * x[14] - 46 * x[15]) + 65 * x[16] + 0 * x[17] - 1 * x[18]) + 39 * x[19] - 20 * x[20] == 20253)</span><br><span class="line">s.add((((((((45 * x[0] - 56 * x[1]) + 10 * x[2] + 650 * x[3] - 900 * x[4]) + 44 * x[5] + 66 * x[6] - 6 * x[7] - 6 * x[8] - 21 * x[9]) + 9 * x[10] - 6 * x[11] - 12 * x[12]) + 69 * x[13] - 2 * x[14] - 406 * x[15]) + 651 * x[16] + 2 * x[17] - 10 * x[18]) + 69 * x[19] - 0 * x[20]) + 21 * x[21] == 18768)</span><br><span class="line">s.add((((((555 * x[0] - 6666 * x[1]) + 70 * x[2] + 510 * x[3] - 90 * x[4]) + 499 * x[5] + 66 * x[6] - 66 * x[7] - 610 * x[8] - 221 * x[9]) + 9 * x[10] - 23 * x[11] - 102 * x[12]) + 6 * x[13] + 2050 * x[14] - 406 * x[15]) + 665 * x[16] + 333 * x[17] + 100 * x[18] + 609 * x[19] + 777 * x[20] + 201 * x[21] - 22 * x[22] == 111844)</span><br><span class="line">s.add((((((((1 * x[0] - 22 * x[1]) + 333 * x[2] + 4444 * x[3] - 5555 * x[4]) + 6666 * x[5] - 666 * x[6]) + 676 * x[7] - 660 * x[8] - 22 * x[9]) + 9 * x[10] - 73 * x[11] - 107 * x[12]) + 6 * x[13] + 250 * x[14] - 6 * x[15]) + 65 * x[16] + 39 * x[17] + 10 * x[18] + 69 * x[19] + 777 * x[20] + 201 * x[21] - 2 * x[22]) + 23 * x[23] == 159029)</span><br><span class="line">s.add((((520 * x[0] - 222 * x[1]) + 333 * x[2] + 4 * x[3] - 56655 * x[4]) + 6666 * x[5] + 666 * x[6] + 66 * x[7] - 60 * x[8] - 220 * x[9]) + 99 * x[10] + 73 * x[11] + 1007 * x[12] + 7777 * x[13] + 2500 * x[14] + 6666 * x[15] + 605 * x[16] + 390 * x[17] + 100 * x[18] + 609 * x[19] + 99999 * x[20] + 210 * x[21] + 232 * x[22] + 23 * x[23] - 24 * x[24] == 2762025)</span><br><span class="line">s.add(((((1323 * x[0] - 22 * x[1]) + 333 * x[2] + 4 * x[3] - 55 * x[4]) + 666 * x[5] + 666 * x[6] + 66 * x[7] - 660 * x[8] - 220 * x[9]) + 99 * x[10] + 3 * x[11] + 100 * x[12] + 777 * x[13] + 2500 * x[14] + 6666 * x[15] + 605 * x[16] + 390 * x[17] + 100 * x[18] + 609 * x[19] + 9999 * x[20] + 210 * x[21] + 232 * x[22] + 23 * x[23] - 24 * x[24]) + 25 * x[25] == 1551621)</span><br><span class="line">s.add((((((777 * x[0] - 22 * x[1]) + 6969 * x[2] + 4 * x[3] - 55 * x[4]) + 666 * x[5] - 6 * x[6]) + 96 * x[7] - 60 * x[8] - 220 * x[9]) + 99 * x[10] + 3 * x[11] + 100 * x[12] + 777 * x[13] + 250 * x[14] + 666 * x[15] + 65 * x[16] + 90 * x[17] + 100 * x[18] + 609 * x[19] + 999 * x[20] + 21 * x[21] + 232 * x[22] + 23 * x[23] - 24 * x[24]) + 25 * x[25] - 26 * x[26] == 948348)</span><br><span class="line">s.add(((((((97 * x[0] - 22 * x[1]) + 6969 * x[2] + 4 * x[3] - 56 * x[4]) + 96 * x[5] - 6 * x[6]) + 96 * x[7] - 60 * x[8] - 20 * x[9]) + 99 * x[10] + 3 * x[11] + 10 * x[12] + 707 * x[13] + 250 * x[14] + 666 * x[15] + -9 * x[16] + 90 * x[17] + -2 * x[18] + 609 * x[19] + 0 * x[20] + 21 * x[21] + 2 * x[22] + 23 * x[23] - 24 * x[24]) + 25 * x[25] - 26 * x[26]) + 27 * x[27] == 777044)</span><br><span class="line">s.add((((((177 * x[0] - 22 * x[1]) + 699 * x[2] + 64 * x[3] - 56 * x[4] - 96 * x[5] - 66 * x[6]) + 96 * x[7] - 60 * x[8] - 20 * x[9]) + 99 * x[10] + 3 * x[11] + 10 * x[12] + 707 * x[13] + 250 * x[14] + 666 * x[15] + -9 * x[16] + 0 * x[17] + -2 * x[18] + 69 * x[19] + 0 * x[20] + 21 * x[21] + 222 * x[22] + 23 * x[23] - 224 * x[24]) + 25 * x[25] - 26 * x[26]) + 27 * x[27] - 28 * x[28] == 185016)</span><br><span class="line">s.add(((((((77 * x[0] - 2 * x[1]) + 6 * x[2] + 6 * x[3] - 96 * x[4] - 9 * x[5] - 6 * x[6]) + 96 * x[7] - 0 * x[8] - 20 * x[9]) + 99 * x[10] + 3 * x[11] + 10 * x[12] + 707 * x[13] + 250 * x[14] + 666 * x[15] + -9 * x[16] + 0 * x[17] + -2 * x[18] + 9 * x[19] + 0 * x[20] + 21 * x[21] + 222 * x[22] + 23 * x[23] - 224 * x[24]) + 26 * x[25] - -58 * x[26]) + 27 * x[27] - 2 * x[28]) + 29 * x[29] == 130106)</span><br><span class="line"></span><br><span class="line">if s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    for i in range(30):</span><br><span class="line">        print(f&quot;x[&#123;i&#125;] = &#123;m[x[i]]&#125;&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;无解&quot;)</span><br></pre></td></tr></table></figure>
<p>得到原x对应的ASCII码，再转成字符即可<br><img src="/meeting/11.10/test1-2.png"><br>再分析py文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">111111116257645365477364777645752361</span><br><span class="line">以上这串数字分别对应的是字符的出现次数,比如HZNUCTF各出现一次</span><br></pre></td></tr></table></figure>
<p>根据以上规律可以得到最后的flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HZNUCTF&#123;ad7fa-76a7-ff6a-fffa-7f7d6a&#125;</span><br></pre></td></tr></table></figure>
<h3 id="test2-水果忍者"><a href="#test2-水果忍者" class="headerlink" title="test2:水果忍者"></a>test2:水果忍者</h3><p>dnspy打开Assembly-CSharp.dll,寻找核心加密，发现是AES，直接Cyberchef一把梭<br><img src="/meeting/11.10/test2-1.png"><br><img src="/meeting/11.10/test2-2.png"><br><img src="/meeting/11.10/test2-3.png"><br><img src="/meeting/11.10/test2-4.png"><br><img src="/meeting/11.10/test2-5.png"></p>
<h3 id="test3-easyGo"><a href="#test3-easyGo" class="headerlink" title="test3:easyGo"></a>test3:easyGo</h3><p>字符串查找flag，寻找可疑字符串，连续两次调用发现判断逻辑<br>输入处下断点后步行，发现右上角直接出现flag<br><img src="/meeting/11.10/test3-1.png"><br><img src="/meeting/11.10/test3-2.png"><br><img src="/meeting/11.10/test3-3.png"><br>当然，也可以判断出加密函数，发现是base64加密，寻找字母表<br><img src="/meeting/11.10/test3-4.png"><br><img src="/meeting/11.10/test3-5.png"><br><img src="/meeting/11.10/test3-6.png"></p>
<h3 id="test4-rustapp"><a href="#test4-rustapp" class="headerlink" title="test4:rustapp"></a>test4:rustapp</h3><p>查找字符串，动态调试，找到核心判断,得到，当v2为0时，输入正确<br>又有v2&#x3D;0,v2&#x3D;v2|(v15^0x21)<br>推断出v15^0x21为0,即v15&#x3D;0x21，即input[i]^rust[i]&#x3D;0x21<br>写出脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    char rust[]=&quot;rust_library_core_assert&quot;;</span><br><span class="line">    char flag[24];</span><br><span class="line">    for(int i=0;i&lt;24;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag[i]=rust[i]^0x21;</span><br><span class="line">        cout&lt;&lt;flag[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STRU~MHCS@SX~BNSD~@RRDSU</span><br></pre></td></tr></table></figure>
<h2 id="2025-11-17"><a href="#2025-11-17" class="headerlink" title="2025.11.17"></a>2025.11.17</h2><h3 id="test1-re1"><a href="#test1-re1" class="headerlink" title="test1:re1"></a>test1:re1</h3><p>入口是简单的花指令，去掉花指令，看伪代码<br>加密两部分，前后换位，异或加密，写出脚本即可<br><img src="/meeting/11.17/test1-1.png"><br><img src="/meeting/11.17/test1-2.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char arr[]=&quot;c~scvdzKCEoDEZ[^roDICUMC&quot;;</span><br><span class="line">   </span><br><span class="line">    for(int i=0;i&lt;12;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int temp=arr[2*i];</span><br><span class="line">        arr[2*i]=arr[2*i+1];</span><br><span class="line">        arr[2*i+1]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    for(int i=0;i&lt;strlen(arr);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i]^=0x30;</span><br><span class="line">        printf(&quot;%c&quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="test2-easyre"><a href="#test2-easyre" class="headerlink" title="test2:easyre"></a>test2:easyre</h3><p>直接UPX脱壳，查找可疑的字符串，发现Part2,左边函数查询part，发现第一部分，得到flag<br><img src="/meeting/11.17/test2-1.png"><br><img src="/meeting/11.17/test2-2.png"><br><img src="/meeting/11.17/test2-3.png"><br>下面讲怎么手脱<br>1，运行到4个push的地方，在第二个push指令处，在右下角下八字节访问硬件断点<br>2，继续运行，发现大跳转，跟进<br>3，找到OEP，直接dump出来<br><img src="/meeting/11.17/test2-4.png"><br><img src="/meeting/11.17/test2-5.png"><br><img src="/meeting/11.17/test2-6.png"><br><img src="/meeting/11.17/test2-7.png"><br><img src="/meeting/11.17/test2-8.png"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Rewp</tag>
      </tags>
  </entry>
  <entry>
    <title>Atri的unity之旅(1)</title>
    <url>/2025/10/19/unity%E4%B9%8B%E6%97%85%E4%B8%80%E2%80%94%E2%80%94%E8%AE%A4%E8%AF%86%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<!-- 这里是摘要部分，以上内容会在首页显示 -->
<p>在本章，我会介绍unity组件基类MonoBehaviour(生命周期函数),组件:Transform,Component相关语法,CharacterController,Rigidbody。</p>
<span id="more"></span>
<!-- 这里是文章的剩余内容 -->

<h2 id="MonoBehaviour-基类与生命周期"><a href="#MonoBehaviour-基类与生命周期" class="headerlink" title="MonoBehaviour 基类与生命周期"></a>MonoBehaviour 基类与生命周期</h2><p>生命周期函数是指那些在游戏对象的生命周期内由Unity引擎自动调用的特殊函数。这些函数按照特定的顺序执行，允许开发者在游戏对象被创建、激活、更新或销毁时执行代码。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Awake ；脚本实例被加载时调用，​无论脚本是否启用。用于初始化变量或游戏状态。</span><br><span class="line">OnEnable:当脚本被启用或激活时调用。​可多次执行​（如物体反复激活/禁用）。</span><br><span class="line">Start:在第一次 Update 调用前，且脚本启用时执行。常用于依赖其他组件完成的初始化。</span><br></pre></td></tr></table></figure>
<h4 id="物理模拟"><a href="#物理模拟" class="headerlink" title="物理模拟"></a>物理模拟</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FixedUpdate：在固定的时间间隔​（默认0.02秒）调用，与帧率无关。​必须用于物理计算​（如力、碰撞）。</span><br><span class="line">OnTrigger[Enter,Stay,Exit]:当碰撞体进入/停留/离开触发器时调用。</span><br><span class="line">OnCollision[Enter,Stay,Exit]：当发生碰撞时调用。</span><br><span class="line">tips：OnCollisionEnter方法必须是在两个碰撞物体都不勾选isTrigger的前提下才能进入，反之只要勾选一个isTrigger那么就能进入OnTriggerEnter方法。</span><br></pre></td></tr></table></figure>
<h4 id="游戏逻辑"><a href="#游戏逻辑" class="headerlink" title="游戏逻辑"></a>游戏逻辑</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Update：每帧调用一次，是游戏核心逻辑（如输入检测、非物理移动）的主要位置。</span><br><span class="line">LateUpdate：在所有 Update 执行完毕后调用。常用于相机跟随，确保目标物体已移动完毕。</span><br></pre></td></tr></table></figure>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OnDisable：当脚本被禁用或物体变为非激活时调用。用于清理当前状态。</span><br><span class="line">OnDestroy：当物体被销毁时调用。用于释放资源、清理内存。</span><br></pre></td></tr></table></figure>
<h2 id="transform-世界的坐标"><a href="#transform-世界的坐标" class="headerlink" title="transform 世界的坐标"></a>transform 世界的坐标</h2><h4 id="位置；"><a href="#位置；" class="headerlink" title="位置；"></a>位置；</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform.position = new Vector();</span><br><span class="line">transform.localPosition = new Vector3();</span><br><span class="line">tips：记得区别世界坐标与相对坐标</span><br></pre></td></tr></table></figure>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置绝对朝向：transform.rotation = Quaternion.Euler();</span><br><span class="line">相对方向旋转：transform.localRotation = Quaternion.Euler();</span><br><span class="line">对应的欧拉角表示为：</span><br><span class="line">transform.eulerAngles = new Vector3();</span><br><span class="line">transform.localeulerAngles = new Vector3();</span><br></pre></td></tr></table></figure>
<h4 id="放缩"><a href="#放缩" class="headerlink" title="放缩"></a>放缩</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform.localScale = new Vector3();</span><br></pre></td></tr></table></figure>
<h4 id="朝向与方向"><a href="#朝向与方向" class="headerlink" title="朝向与方向"></a>朝向与方向</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform.[up,forward,right]：是以物体自身为坐标轴重建的正方向。</span><br></pre></td></tr></table></figure>
<h4 id="父与子"><a href="#父与子" class="headerlink" title="父与子"></a>父与子</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform.SetParent(Transform parent, bool worldPositionStays = true);</span><br><span class="line">Transform top = transform.root;//设置top为最高层级</span><br></pre></td></tr></table></figure>
<h4 id="坐标系转换"><a href="#坐标系转换" class="headerlink" title="坐标系转换"></a>坐标系转换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vector worldpoint=transfom.TransformPoint(localpoint)；//将相对this的局部坐标转化为世界坐标</span><br><span class="line">Vector3 localPoint = A.transform.InverseTransformPoint(worldPoint);//将世界坐标转化为相对于A的局部坐标</span><br><span class="line">Vector3 worldDirection = TransformDirection(localDirection);//将局部方向转换为世界方向</span><br><span class="line">Vector3 localDirection = InverseTransformDirection(worldDirection);//transformDirection的逆方向</span><br><span class="line">TransformVector(Vector3 localVector)/InverseTransformVector(Vector3 worldVector)//效果同上，但是会考虑缩放</span><br></pre></td></tr></table></figure>
<h4 id="移动与旋转"><a href="#移动与旋转" class="headerlink" title="移动与旋转"></a>移动与旋转</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform.Translate(Vector3.forward * Time.deltaTime * speed);//// 默认为 Space.Self</span><br><span class="line">transform.Translate(Vector3.right * 1f, Space.World);//世界坐标下的移动</span><br><span class="line">transform.Rotate();//方向*度数（默认为本地坐标）</span><br><span class="line">LookAt(Transform target)/LookAt(Vector3 worldPosition)//看向物体</span><br><span class="line">Quaternion targetRot = Quaternion.LookRotation(targetPos - transform.position);//生成四元数朝向（用于平滑旋转或插值）</span><br><span class="line">transform.SetPositionAndRotation(newPos, Quaternion.Euler());//同时设置位置与旋转</span><br></pre></td></tr></table></figure>
<h2 id="Component-组件"><a href="#Component-组件" class="headerlink" title="Component 组件"></a>Component 组件</h2><h4 id="获取组件"><a href="#获取组件" class="headerlink" title="获取组件"></a>获取组件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例：Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();//获取某个游戏对象的组件</span><br><span class="line">例：Transform childTransform = gameObject.transform.GetChild(0).GetComponent&lt;Transform&gt;();//获取子对象的组件</span><br></pre></td></tr></table></figure>
<h4 id="添加组件"><a href="#添加组件" class="headerlink" title="添加组件"></a>添加组件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rigidbody rb = gameObject.AddComponent&lt;Rigidbody&gt;()//为物体添加组件</span><br><span class="line">MyScript myScript = gameObject.AddComponent&lt;MyScript&gt;();//为物体添加脚本</span><br></pre></td></tr></table></figure>
<h4 id="移除组件"><a href="#移除组件" class="headerlink" title="移除组件"></a>移除组件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Destroy(gameObject.GetComponent&lt;Collider&gt;(), time);//time表示销毁延迟（可省）</span><br></pre></td></tr></table></figure>
<h4 id="启用与禁用"><a href="#启用与禁用" class="headerlink" title="启用与禁用"></a>启用与禁用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Component.enabled=(bool);</span><br></pre></td></tr></table></figure>
<h4 id="通过类型获取组件"><a href="#通过类型获取组件" class="headerlink" title="通过类型获取组件"></a>通过类型获取组件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collider[] colliders = gameObject.GetComponents&lt;Collider&gt;();//获取所有collider组件</span><br><span class="line">Rigidbody rbInChildren = gameObject.GetComponentInChildren&lt;Rigidbody&gt;();//获取子物体组件</span><br><span class="line">TryGetComponent//尝试获取组件(if)</span><br></pre></td></tr></table></figure>
<h2 id="Rigidbody-刚体"><a href="#Rigidbody-刚体" class="headerlink" title="Rigidbody 刚体"></a>Rigidbody 刚体</h2><h4 id="物理力相关"><a href="#物理力相关" class="headerlink" title="物理力相关"></a>物理力相关</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddForce//施加力，可以指定力的类型</span><br><span class="line">Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">Vector3 force = new Vector3(10f, 0f, 0f); //设置力的方向</span><br><span class="line">rb.AddForce(force,ForceMode.Impulse);</span><br><span class="line">//四种ForceMode：Force,Acceleraton,Impulse,VelocityChange</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddTorque//添加扭矩用于模拟旋转</span><br><span class="line">Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">Vector3 torque = new Vector3(0f, 10f, 0f); // 沿 Y 轴的旋转</span><br><span class="line">rb.AddTorque(torque);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddRelativeForce//添加本地系力</span><br><span class="line">Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">Vector3 localForce = new Vector3(10f, 0f, 0f); // 在本地空间内的力</span><br><span class="line">rb.AddRelativeForce(localForce);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddRelativeTorque//添加本地系扭矩</span><br><span class="line">Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">Vector3 localTorque = new Vector3(0f, 5f, 0f); // 在本地空间内的扭矩</span><br><span class="line">rb.AddRelativeTorque(localTorque);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddForceAtPosition(Vector3 force, Vector3 position)//在指定位置创造力</span><br></pre></td></tr></table></figure>
<h4 id="状态控制函数"><a href="#状态控制函数" class="headerlink" title="状态控制函数"></a>状态控制函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sleep()// 让物体进入休眠状态</span><br><span class="line">Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">rb.Sleep();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WakeUp()//唤醒刚体，使其重新参与物理计算</span><br><span class="line">Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">rb.WakeUp();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IsSleeping()// 返回物体是否休眠的状态</span><br><span class="line">Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">bool isSleeping = rb.IsSleeping(); </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DetectCollisions//是否进行碰撞检测</span><br><span class="line">Rigidbody rb = gameObject.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">rb.detectCollisions = true;</span><br></pre></td></tr></table></figure>
<h4 id="物理属性设置函数"><a href="#物理属性设置函数" class="headerlink" title="物理属性设置函数"></a>物理属性设置函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">velocity//速度</span><br><span class="line">angularVelocity//角速度</span><br><span class="line">drag//线性阻力</span><br><span class="line">angularDrag//角阻力</span><br><span class="line">mass//质量</span><br><span class="line">useGravity//是否启用重力</span><br><span class="line">isKinematic//是否是运动学物体</span><br><span class="line">constraints//设置物体约束</span><br><span class="line">Vector:Velocity,angularVelocity</span><br><span class="line">float:drag angulaiDrag mass</span><br><span class="line">bool:useGravity,isKinematic</span><br></pre></td></tr></table></figure>
<h4 id="位移与旋转"><a href="#位移与旋转" class="headerlink" title="位移与旋转"></a>位移与旋转</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MovePosition(Vector3 position)</span><br><span class="line">MoveRotation(Quaternion rot)</span><br></pre></td></tr></table></figure>
<h2 id="CharacterController-角色控制器"><a href="#CharacterController-角色控制器" class="headerlink" title="CharacterController 角色控制器"></a>CharacterController 角色控制器</h2><h4 id="移动与碰撞函数"><a href="#移动与碰撞函数" class="headerlink" title="移动与碰撞函数"></a>移动与碰撞函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">move()</span><br><span class="line">CharacterController cc = GetComponent&lt;CharacterController&gt;();</span><br><span class="line">Vector3 move = new Vector3(0, 0, 5f) * Time.deltaTime;</span><br><span class="line">CollisionFlags flag = cc.Move(move);//返回碰撞信息</span><br><span class="line">//None：无碰撞/Sides：侧面碰撞/Above：上方碰撞/Below：下方碰撞（落地）</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SimpleMove(Vector3 speed)//与Move类似，但自动添加重力效果</span><br><span class="line">bool SimpleMove(Vector3 speed);//true：落地,flase：在空中</span><br></pre></td></tr></table></figure>
<h4 id="检测与状态属性"><a href="#检测与状态属性" class="headerlink" title="检测与状态属性"></a>检测与状态属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isGrounded//判断角色是否在地面上</span><br><span class="line">velocity//返回当前速度</span><br><span class="line">enabled//启用或禁用</span><br></pre></td></tr></table></figure>
<h4 id="物理属性"><a href="#物理属性" class="headerlink" title="物理属性"></a>物理属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">height</span><br><span class="line">radius</span><br><span class="line">center</span><br><span class="line">skinwidth</span><br></pre></td></tr></table></figure>
<h4 id="爬坡设置"><a href="#爬坡设置" class="headerlink" title="爬坡设置"></a>爬坡设置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stepOffset//角色可以跨越的最大台阶高度</span><br><span class="line">slopeLimit//可行走的最大坡度角度</span><br><span class="line">minMoveDistance//忽略的最小位移距离</span><br></pre></td></tr></table></figure>
<h4 id="碰撞等检测"><a href="#碰撞等检测" class="headerlink" title="碰撞等检测"></a>碰撞等检测</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">detectCollisons//同上</span><br><span class="line">enableOverlapRecovery//是否在卡入障碍物后自动推出</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Atri的Re之旅(1)</title>
    <url>/2025/10/20/Atri%E7%9A%84Re%E4%B9%8B%E6%97%85-1/</url>
    <content><![CDATA[<!-- 这里是摘要部分，以上内容会在首页显示 -->
<p>本章我会带来moectf2025-Re向的非官方WP</p>
<span id="more"></span>
<!-- 这里是文章的剩余内容 -->
<h2 id="test1-speed"><a href="#test1-speed" class="headerlink" title="test1:speed"></a>test1:speed</h2><p>1，die查壳，发现无壳<br>2,运行exe，发现打开后迅速结束窗口<br>3，打开ida<br><img src="/moectf/speed1.png" alt="ida"><br>4,追踪WinMain函数，发现sleep(1u),设下断点<br><img src="/moectf/speed2.png" alt="ida"><br>5,动态调试<br><img src="/moectf/speed3.png" alt="ida"></p>
<h2 id="test2-base"><a href="#test2-base" class="headerlink" title="test2:base"></a>test2:base</h2><p>1，die查壳：无壳的PE64文件<br>2，虚拟机运行，发现需要填写flag<br>3，打开ida<br>4，Main函数：<br><img src="/moectf/base1.png" alt="ida"><br>5，用cyberchef翻译base64<br><img src="/moectf/base2.png" alt="cyberchef"></p>
<h2 id="test3-catch"><a href="#test3-catch" class="headerlink" title="test3:catch"></a>test3:catch</h2><p>1，打开ida，查找可疑字符串<br><img src="/moectf/catch1.png" alt="ida"><br>2,发现字符串位数与moectf{}一致，怀疑是凯撒密码，解密后得到flag<br><img src="/moectf/catch2.png" alt="decrypt"></p>
<h2 id="test4-upx"><a href="#test4-upx" class="headerlink" title="test4:upx"></a>test4:upx</h2><p>1，根据题目提示，die查壳<br><img src="/moectf/upx1.png" alt="die"><br>2,upx去壳<br><img src="/moectf/upx2.png" alt="upx"><br>3,打开ida，查找可能的字符串，最后发现核心加密在main函数<br><img src="/moectf/upx3.png" alt="upx"><br>4,分析函数，先寻找密文<br><img src="/moectf/upx4.png" alt="upx"><br>5，将密文重新组合后写出脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   unsigned char encrypt[]=&#123;</span><br><span class="line">    0x00000023, 0x0000002B, 0x00000027, 0x00000036,</span><br><span class="line">    0x00000033, 0x0000003C, 0x00000003, 0x00000048,</span><br><span class="line">    0x00000064, 0x0000000B, 0x0000001D, 0x00000076,</span><br><span class="line">    0x0000007B, 0x00000010, 0x0000000B, 0x0000003A,</span><br><span class="line">    0x0000003F, 0x00000065, 0x00000076, 0x00000029,</span><br><span class="line">    0x00000015, 0x00000037, 0x0000001C, 0x0000000A,</span><br><span class="line">    0x00000008, 0x00000021, 0x0000003E, 0x0000003C,</span><br><span class="line">    0x0000003D, 0x00000016, 0x0000000B, 0x00000024,</span><br><span class="line">    41,36,86</span><br><span class="line">   &#125;;//注意密文的顺序</span><br><span class="line">   unsigned char flag[]=&#123;&#125;;</span><br><span class="line">   flag[35]=&#x27;\n&#x27;;//根据提示，我们可以得知flag的最后一位是换行符</span><br><span class="line">   for(int i=34;i&gt;=0;i--)</span><br><span class="line">   &#123;</span><br><span class="line">    flag[i]=encrypt[i]^0x21^flag[i+1];</span><br><span class="line">   &#125;</span><br><span class="line">   for(int i=0;i&lt;=34;i++)</span><br><span class="line">   &#123;</span><br><span class="line">    cout&lt;&lt;flag[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Rewp</tag>
      </tags>
  </entry>
  <entry>
    <title>日报——记录我的每一天</title>
    <url>/2025/11/14/%E6%97%A5%E6%8A%A5%E2%80%94%E8%AE%B0%E5%BD%95%E6%88%91%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<!-- 这里是摘要部分，以上内容会在首页显示 -->
<p>用来记录我的生活和学习，不具有学习价值。</p>
<span id="more"></span>
<!-- 这里是文章的剩余内容 -->
<h2 id="2025-11"><a href="#2025-11" class="headerlink" title="2025&#x2F;11"></a>2025&#x2F;11</h2><h3 id="2025-11-14"><a href="#2025-11-14" class="headerlink" title="2025.11.14"></a>2025.11.14</h3><h4 id="阅读书籍"><a href="#阅读书籍" class="headerlink" title="阅读书籍"></a>阅读书籍</h4><p>《C Primer Plus》第1-4章</p>
<h4 id="今日工作"><a href="#今日工作" class="headerlink" title="今日工作"></a>今日工作</h4><p>1，重温了一下C语言的基础部分，突然发现自己有很多遗漏的东西<br>2，顺带着用ida，x32dbg调试了一下自己写的程序，感觉还挺新奇的<br>3，做了点基础的编程题（突然发现自己对print其实不是特别了解来着）<br>4，今天没有做逆向工作，明天得做点题了</p>
<h4 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h4><p>感冒真的好难受，想睡觉，感觉自己被挂了个学习效率下降的debuff</p>
<h3 id="2025-11-15"><a href="#2025-11-15" class="headerlink" title="2025.11.15"></a>2025.11.15</h3><p>今天什么也没做，生病休息一天。</p>
<h3 id="2025-11-16"><a href="#2025-11-16" class="headerlink" title="2025.11.16"></a>2025.11.16</h3><p>今天什么也没做，生病休息一天。</p>
<h3 id="2025-11-17"><a href="#2025-11-17" class="headerlink" title="2025.11.17"></a>2025.11.17</h3><h4 id="阅读书籍-1"><a href="#阅读书籍-1" class="headerlink" title="阅读书籍"></a>阅读书籍</h4><p>《C Primer Plus》第5-7章；各种结构语句的学习（因为有基础所以看得挺快）</p>
<h4 id="今日工作-1"><a href="#今日工作-1" class="headerlink" title="今日工作"></a>今日工作</h4><p>1，上re方向的周例会<br>2，继续攻防世界做题</p>
<h4 id="几日打算"><a href="#几日打算" class="headerlink" title="几日打算"></a>几日打算</h4><p>1，可能最近得快点结束C了<br>2，后面考虑对着专门的逆向书学一下基础知识<br>3，这周争取能阅读一点CSAPP<br>4，找个时间写个完整一页的攻防世界的wp<br>5，重启QCTF和moeCTF的wp计划</p>
<h3 id="2025-11-18"><a href="#2025-11-18" class="headerlink" title="2025.11.18"></a>2025.11.18</h3><h4 id="阅读书籍-2"><a href="#阅读书籍-2" class="headerlink" title="阅读书籍"></a>阅读书籍</h4><p>C Primer Plus》第8-9.5章</p>
<h4 id="今日工作-2"><a href="#今日工作-2" class="headerlink" title="今日工作"></a>今日工作</h4><p>C语言学了函数的基本部分，以及I&#x2F;O处理<br>主要处理了一下例会的作业</p>
<h4 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h4><p>学习了怎么手脱upx<br>看了几篇blog，花指令应该暂时收工了</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日报</tag>
      </tags>
  </entry>
  <entry>
    <title>记一道逆向题</title>
    <url>/2025/10/27/%E8%AE%B0%E4%B8%80%E9%81%93%E9%80%86%E5%90%91%E9%A2%98/</url>
    <content><![CDATA[<!-- 这里是摘要部分，以上内容会在首页显示 -->
<p>突然得到一道安卓逆向题，这就<del>逝逝</del></p>
<span id="more"></span>
<!-- 这里是文章的剩余内容 -->
<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>1.解出正确的用户名密码（10pts）<br>2.根据逻辑使用c语言恢复正向加密逻辑（15pts）<br>3.写出c语言逆向解密逻辑（15pts）<br>4.成功使用logcat捕获log信息（10pts）<br>5.借助log出来的信息完成对用户名密码的分析（25pts）<br><del>6.通过修改文件逻辑让其自输出正确的密码（15pts）</del>&#x2F;&#x2F;出题人自己做不出来()<br>6,尝试绕过登录页面进入程序<br>7.wp能够清晰，详细的体现分析过程（10pts)<br>为了避免ai一把梭，从第二点开始。</p>
<h3 id="test1-2-3"><a href="#test1-2-3" class="headerlink" title="test1,2,3"></a>test1,2,3</h3><p>1,打开jadx，加载apk，我们发现LoginActivity，进一步寻找，发现lib文件ndk01。<br><img src="/jsnow/1.png"><br><img src="/jsnow/2.png"><br>2,将apk更改后缀名后解压，得到libndk01.so，放进ida,注意到左侧的login，跳转翻看伪代码。<br><img src="/jsnow/3.png"><br><img src="/jsnow/4.png"><br><img src="/jsnow/5.png"><br>3,通过图示分析,得到账户：CTFer，并且发现最后检验为s与v29<br><img src="/jsnow/6.png"><br><img src="/jsnow/7.png"><br>4,获取byte_6F0,分析变种rc4加密<br><img src="/jsnow/9.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加密</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char v32[256];</span><br><span class="line">    unsigned char v33[256];</span><br><span class="line">    string ezAndroid =&quot;ezAndroid&quot;;</span><br><span class="line">    for(int n=0;n &lt; 256;n=n+2)</span><br><span class="line">    &#123;</span><br><span class="line">        v32[n]=n&amp; 0xCC;</span><br><span class="line">        v32[n+1]=n&amp; 0xCC;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int n=0;n != 256;n=n+2)</span><br><span class="line">    &#123;</span><br><span class="line">        string ezAndroid =&quot;ezAndroid&quot;;</span><br><span class="line">        v33[n]=ezAndroid[(n ^ 0x20uLL) % 9];</span><br><span class="line">        v33[n+1]=ezAndroid[(n ^ 0x21uLL) % 9];</span><br><span class="line">    &#125;</span><br><span class="line">    int v11=0,v12,v14;</span><br><span class="line">    for(int n256_1=0; n256_1 &lt; 256; ++n256_1)</span><br><span class="line">    &#123;</span><br><span class="line">        v12 = v32[n256_1];</span><br><span class="line">        v14 = v33[n256_1];</span><br><span class="line">        v11 = (v11 + v12 + v14) % 256; </span><br><span class="line">        unsigned char temp = v32[n256_1];</span><br><span class="line">        v32[n256_1] = v32[v11];</span><br><span class="line">        v32[v11] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    char s[41]= &quot;0aecbfedb9dd6b968dabe69b18693d6b1bd6146&quot;;</span><br><span class="line">     int v18=0, v20=0; </span><br><span class="line">    for(int v19=0; v19&lt;40; v19++)</span><br><span class="line">    &#123;</span><br><span class="line">        v18 = (v18 + 1) % 256;</span><br><span class="line">        unsigned char v22 = v32[v18];</span><br><span class="line">        v20 = (v20 + v22) % 256;</span><br><span class="line">        unsigned char temp = v32[v18];</span><br><span class="line">        v32[v18] = v32[v20];</span><br><span class="line">        v32[v20] = temp;</span><br><span class="line">        s[v19] += v32[(v22 + v32[v18])%256];</span><br><span class="line">    &#125;</span><br><span class="line">    char ss[41];</span><br><span class="line">    for(int i = 0; i &lt; 40; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ss[i]= s[i]^0xCC;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i &lt; 40; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; hex &lt;&lt; setfill(&#x27;0&#x27;) &lt;&lt; setw(2) &lt;&lt; (int)(unsigned char)ss[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解密</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //v32,v33初始化</span><br><span class="line">  unsigned  char v32[256];</span><br><span class="line">    for(int n=0;n &lt; 256;n=n+2)</span><br><span class="line">    &#123;</span><br><span class="line">        v32[n]=n&amp; 0xCC;</span><br><span class="line">        v32[n+1]=n&amp; 0xCC;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char v33[256];</span><br><span class="line">    for(int n=0;n != 256;n=n+2)</span><br><span class="line">    &#123;</span><br><span class="line">        string ezAndroid =&quot;ezAndroid&quot;;</span><br><span class="line">        v33[n]=ezAndroid[(n ^ 0x20uLL) % 9];</span><br><span class="line">        v33[n+1]=ezAndroid[(n ^ 0x21uLL) % 9];</span><br><span class="line">    &#125;</span><br><span class="line">    //获取新的v32,v33</span><br><span class="line">    int v11=0,v12,v13,v14,v15,v16,n256_1=0;</span><br><span class="line">    do</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = v32[n256_1];</span><br><span class="line">    v13 = v12 + v11;</span><br><span class="line">    v14 = v33[n256_1];</span><br><span class="line">    v15 = v14 + v13 + 255;</span><br><span class="line">    v16 = v14 + v13;</span><br><span class="line">    if ( v16 &gt;= 0 )</span><br><span class="line">      v15 = v16;</span><br><span class="line">    v11 = v16 - (v15 &amp; 0xFFFFFF00);</span><br><span class="line">    </span><br><span class="line">    v32[n256_1] = v32[v11];</span><br><span class="line">    v32[v11] = v12;</span><br><span class="line">    ++n256_1;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( n256_1 != 256 );</span><br><span class="line">  //获取密文</span><br><span class="line">  unsigned char miwen[]=&#123;0xB0, 0xE9, 0x7D, 0xAF, 0x6E, 0xE2, 0xE9, 0x60, 0x6A, 0xCD,</span><br><span class="line">        0x7C, 0xFC, 0x72, 0xE2, 0x4D, 0x36, 0xF4, 0xBC, 0x2D, 0x2E,</span><br><span class="line">        0x29, 0x0E, 0x89, 0x62, 0xBD, 0x08, 0xB6, 0xF5, 0x73, 0x7C, 0xF6,</span><br><span class="line">        0x2A, 0x71, 0x26, 0x7C, 0x0E, 0xBD, 0xB0, 0x3A, 0xCC&#125;;</span><br><span class="line">   unsigned char v29[]=&#123;&#125;;</span><br><span class="line">   v29[0]=124;</span><br><span class="line">    for(int i=1;i&lt;40;i++)</span><br><span class="line">    &#123;</span><br><span class="line">     </span><br><span class="line">     v29[i]= miwen[i]^0xCC;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //解密</span><br><span class="line">    int v18=0,v22=0,v20=0,v24=0;</span><br><span class="line">    char s[41];</span><br><span class="line">    for(int v19=0;v19&lt;41;v19++)</span><br><span class="line">    &#123;        </span><br><span class="line"></span><br><span class="line">v18=(v18+1)%256;</span><br><span class="line">v22 = v32[v18];</span><br><span class="line">v24=v22+v20;</span><br><span class="line">v20=v24%256;</span><br><span class="line">v32[v18]=v32[v20];</span><br><span class="line">v32[v20]=v22;</span><br><span class="line">s[v19]=v29[v19]-v32[(v22+v32[v18])%256];</span><br><span class="line">;</span><br><span class="line">    &#125;</span><br><span class="line">    s[40] = &#x27;\0&#x27;;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到最后的密码<br><img src="/jsnow/8.png"></p>
<h3 id="test4-5"><a href="#test4-5" class="headerlink" title="test4,5"></a>test4,5</h3><p>根据问题，打开AS，输入以下指令监听</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat -s JSnow</span><br></pre></td></tr></table></figure>
<p><img src="/jsnow/10.png"><br>接下来我们分析so层的核心加密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do</span><br><span class="line">   &#123;</span><br><span class="line">     v21 = v18 + 256;</span><br><span class="line">     if ( v18 + 1 &gt;= 0 )</span><br><span class="line">       v21 = v18 + 1;</span><br><span class="line">     v18 = v18 - (v21 &amp; 0xFFFFFF00) + 1;</span><br><span class="line">     v22 = *(v31 + v18);</span><br><span class="line">     v23 = v20 + v22 + 255;</span><br><span class="line">     v24 = v22 + v20;</span><br><span class="line">     if ( v24 &gt;= 0 )</span><br><span class="line">       v23 = v24;</span><br><span class="line">     v20 = v24 - (v23 &amp; 0xFFFFFF00);</span><br><span class="line">     *(v31 + v18) = *(v31 + v20);</span><br><span class="line">     *(v31 + v20) = v22;</span><br><span class="line">     s[v19++] += *(v31 + (v22 + *(v31 + v18)));</span><br><span class="line">   &#125;</span><br><span class="line">   while ( v17 != v19 );</span><br></pre></td></tr></table></figure>
<p>我们可以发现一件事,即对每一次循环而言，直接有关加密字符的其实就最后一步<br>那我们结合logcat,<del>前面账号输错了我就说为什么没结果</del><br><img src="/jsnow/11.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s[v19++] += *(v31 + (v22 + *(v31 + v18)));</span><br><span class="line">可以简化成s[v19]=s[v19]+P，且有P在每个循环中变动</span><br><span class="line">我们会发现logcat返回的其实是输入密码[记作A]的加密后结果[记作B],以及应该得到的加密后正确值[记作C]</span><br><span class="line">那么我们可以得到</span><br><span class="line">正确密码=C-(B-A)</span><br><span class="line">这样，我们可以通过得到一个密文便计算一个明文的方式得到最后的密码</span><br></pre></td></tr></table></figure>
<h3 id="test6"><a href="#test6" class="headerlink" title="test6"></a>test6</h3><p>我们也可以修改ida的汇编指令<br>注意到程序的log输出循环中的这一判定条件，对应的汇编指令如图所示，我们可以将jz修改为jmp(恒成立)<br><img src="/jsnow/12.png"><br><img src="/jsnow/13.png"><br>修改后的伪代码如图<br><img src="/jsnow/14.png"><br>这样当我们if条件成立时，我们可以直接得到”login success”的反馈<br>根据前面，我们得知，即输入的密码首字母加密后应该为7c,即密码明文首字母为0，这样就成功绕过登录判断得到结果了<br><img src="/jsnow/15.png"><br><img src="/jsnow/16.png"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Rewp</tag>
      </tags>
  </entry>
  <entry>
    <title>自我介绍</title>
    <url>/2025/10/27/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>这里是AtriNo.1,一位刚入门的CTFer，主攻Re，也会玩点misc。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Re</tag>
        <tag>Fresher</tag>
      </tags>
  </entry>
</search>
